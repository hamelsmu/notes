<p>Notes from the book <a href="https://www.manning.com/books/docker-in-action-second-edition?utm_source=google&amp;utm_medium=search&amp;utm_campaign=dynamicsearch&amp;gclid=CjwKCAjwmMX4BRAAEiwA-zM4JtyXLeFoALyh7xvEtg9B7nTbf3VeOFzo6Sdu119z94d6cll6XsbKgxoCRmMQAvD_BwE">Docker In Action</a></p>

<p>import TOCInline from ‘@theme/TOCInline’;</p>

<p>&lt;TOCInline toc={toc} /&gt;;</p>

<h1 id="chapter-1">Chapter 1</h1>
<ul>
  <li>Docker containers are faster than VMs to start, partly because they do NOT offer any hardware virtualization.
    <ul>
      <li>VMs provide hardware abstractions so you can run operating systems.</li>
    </ul>
  </li>
  <li>Docker uses Linux <code class="language-plaintext highlighter-rouge">namespaces</code> and <code class="language-plaintext highlighter-rouge">cgropus</code>
    <ul>
      <li>Hamel: I don’t know what this is</li>
    </ul>
  </li>
</ul>

<h1 id="chapter-2">Chapter 2</h1>

<ul>
  <li>Getting help:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">docker help cp</code></li>
      <li><code class="language-plaintext highlighter-rouge">docker help run</code></li>
    </ul>
  </li>
  <li>Linking containers:  <code class="language-plaintext highlighter-rouge">docker run --link</code>
    <ul>
      <li>this is <a href="https://docs.docker.com/network/links/">apparently deprecated</a> per the docs</li>
      <li>Opens a secure tunnel between two containers automatically</li>
      <li>Also exposes environment variables and other things (see the docs)</li>
    </ul>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">docker cp</code>   copy files from a container to local filesystem</p>
  </li>
  <li>Detach an interactive container:
    <ul>
      <li>Hold down <code class="language-plaintext highlighter-rouge">Control</code> and press <code class="language-plaintext highlighter-rouge">P</code> then <code class="language-plaintext highlighter-rouge">Q</code></li>
    </ul>
  </li>
  <li>Get logs <code class="language-plaintext highlighter-rouge">docker logs &lt;container name&gt;</code>
    <ul>
      <li>Hamel: This is like <code class="language-plaintext highlighter-rouge">kubectl logs</code></li>
    </ul>
  </li>
  <li>Run a new command in a running container <code class="language-plaintext highlighter-rouge">docker exec</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">docker exec &lt;container_name&gt; ps</code> will run the <code class="language-plaintext highlighter-rouge">ps</code> command and emit that to stdout</li>
    </ul>
  </li>
  <li>
    <p>Rename a container with <code class="language-plaintext highlighter-rouge">docker rename &lt;current_name&gt; &lt;new_name&gt;</code></p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">docker exec</code> run additional processes in an already running container</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">docker create</code> is the same as <code class="language-plaintext highlighter-rouge">docker run</code> except that the container is created in a stopped state.</p>
  </li>
  <li><code class="language-plaintext highlighter-rouge">docker run --read-only</code> allows you to run a container in a read only state, which you only need to do in special circumstances (you probably never need to use this).   You can make exceptions to the read only constraint with the <code class="language-plaintext highlighter-rouge">-v</code> flag:</li>
</ul>

<p><img src="Docker-In-Action/6453FD28-1552-474C-9869-F6E01C6EC9C8.png" alt="" /></p>

<ul>
  <li>Override the entrypoint using the <code class="language-plaintext highlighter-rouge">--entrypoint</code> flag (this is discussed in part 2 of the book).</li>
</ul>

<p><img src="Docker-In-Action/276CD61C-3D6F-485A-8D88-8C2DD2EF8B5D.png" alt="" /></p>

<h3 id="injecting-environment-variables">Injecting environment variables</h3>

<p>With the <code class="language-plaintext highlighter-rouge">--env</code> or <code class="language-plaintext highlighter-rouge">-e</code> flags.<br />
A nice trick to see all the environment variables in a docker container is to use the Unix command <code class="language-plaintext highlighter-rouge">env</code></p>

<p><img src="Docker-In-Action/2070CA60-7C95-4BE8-B2C8-F68FF6B09C66.png" alt="" /></p>

<p>Setting multiple environment variables: use <code class="language-plaintext highlighter-rouge">\</code> for multiline like this:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker create <span class="se">\</span>
  <span class="nt">--env</span> <span class="nv">WORDPRESS_DB_HOST</span><span class="o">=</span>&lt;my database <span class="nb">hostname</span><span class="o">&gt;</span> <span class="se">\</span>
  <span class="nt">--env</span> <span class="nv">WORDPRESS_DB_USER</span><span class="o">=</span>site_admin <span class="se">\</span>
  <span class="nt">--env</span> <span class="nv">WORDPRESS_DB_PASSWORD</span><span class="o">=</span>MeowMix42 <span class="se">\ </span>
wordpress:4
</code></pre></div></div>

<h3 id="automatically-restarting-containers">Automatically restarting containers</h3>

<p>Docker uses an exponential backoff strategy - double the previous time waiting until restarting.</p>

<p><code class="language-plaintext highlighter-rouge">docker run -d --restart always ... </code></p>

<p>See <a href="https://docs.docker.com/engine/reference/run/#restart-policies---restart">these restart policies</a></p>

<ul>
  <li>no</li>
  <li>on-failure[:max-retries]</li>
  <li>always</li>
  <li>unless-stopped</li>
</ul>

<h3 id="removing-containers-vs-images">Removing containers vs. images</h3>

<p><strong>Containers are the actual instantiation of an image</strong>, just like how an object is an instantion of an instance of a class.</p>

<p><code class="language-plaintext highlighter-rouge">docker rm</code>: remove a container
<code class="language-plaintext highlighter-rouge">docker rmi</code>: remove an image</p>

<h1 id="chapter-3">Chapter 3</h1>

<ul>
  <li>Two ways to publish an image
    <ul>
      <li>Build locally, push image to registry</li>
      <li>Make a <code class="language-plaintext highlighter-rouge">Dockerfile</code> and use DockerHub’s build system.  <strong>This is preferred and considered to be safer, and DockerHub will mark your image as trusted if you do this</strong> because it is the only way to provide transparency to what is in your image.</li>
    </ul>
  </li>
  <li>Search dockerhub by keyword , sorted descending by stars
    <ul>
      <li><code class="language-plaintext highlighter-rouge">docker search &lt;keyword&gt;</code></li>
      <li>example:  <code class="language-plaintext highlighter-rouge">docker search postgres</code></li>
    </ul>
  </li>
  <li>Using Alternative registries
    <ul>
      <li><code class="language-plaintext highlighter-rouge">docker pull quay.io/dockerinaction/ch3_hello_registry:latest</code></li>
    </ul>
  </li>
</ul>

<h3 id="images-as-files">Images as files</h3>

<p>You can transport, save and load images as files!  (You don’t have to push them to a registry).</p>

<p><img src="Docker-In-Action/AD7BCDC9-8130-45AE-89A9-DE5410EE845B.png" alt="" /></p>

<p>You can then load the image:</p>

<p><code class="language-plaintext highlighter-rouge">docker load -i myfile.tar</code></p>

<h1 id="chapter-4-persistent-storage--shared-state-with-volumes">Chapter 4 Persistent Storage &amp;. Shared State with Volumes</h1>
<p><code class="language-plaintext highlighter-rouge">-v</code> and <code class="language-plaintext highlighter-rouge">--volume</code> are aliases</p>

<p><code class="language-plaintext highlighter-rouge">--volumes-from="&lt;container-name&gt;"</code>  Mount all volumes from the given container</p>

<h3 id="different-kind-of-volumes">Different kind of Volumes</h3>
<ol>
  <li>Bind mount - this is what you always use</li>
  <li>Docker managed volume (2 kinds)
    <ol>
      <li>Anonymous</li>
      <li>Named volume (a special case of Anonymous)</li>
    </ol>
  </li>
</ol>

<p><a href="https://docs.docker.com/storage/volumes/">Use volumes | Docker Documentation</a>
	- Named vs. Anonymous volumes: <a href="https://medium.com/faun/what-are-anonymous-and-named-volumes-6cd787822a7d">article</a>
	- Hamel: maybe? You might use named volumes to persist data between containers.</p>

<h3 id="to-persist-data-with-named-volumes">To persist data with named volumes</h3>

<p>Named volume is a kind of anonymous volume where the mount point is managed by Docker.  Example of how you used a named volume:</p>

<ol>
  <li>
    <p>Start container with a <strong>named volume</strong>:
 <code class="language-plaintext highlighter-rouge">docker run --name myDatabaseWithVolume -v appdata:/var/lib/mysql  mysql</code>
 save a table in the mysql database</p>
  </li>
  <li>
    <p>Start a new container with the same <strong>named volume</strong>
 <code class="language-plaintext highlighter-rouge">docker run --name myDatabaseWithVolume2 -v appdata:/var/lib/mysql mysql</code>
    You should be able to see the same table you created in the last container b/c data has been persisted.</p>
  </li>
</ol>

<h3 id="see-where-docker-anonymous-volumes-store-information">See where Docker anonymous volumes store information</h3>

<p>Unlike a bind mount, where you explicitly name the host location, docker will manage the storage location of anonymous volumes.  But how do you know where the files are stored on the host?</p>

<p>You can use <code class="language-plaintext highlighter-rouge">docker inspect</code> command filtered for the <code class="language-plaintext highlighter-rouge">Volumes</code> key to find the storage location on the host.</p>

<p>Create a container with an anonymous volume.
<code class="language-plaintext highlighter-rouge">docker run -v /some/location --name cass-shared alpine</code></p>

<p><code class="language-plaintext highlighter-rouge">docker inspect -f "" cass-shared</code></p>

<p>This will output a json blob which will show the mount points.</p>

<h3 id="other-things-you-didnt-know-about-volumes">Other things you didn’t know about volumes</h3>
<ul>
  <li>when you mount a volume, it overrides any files already at that location
    <ul>
      <li>You can mount specific files which avoid this</li>
      <li>if you specify a host directory that doesn’t exist Docker will create it for you
        <ul>
          <li>exception: If you are mounting a file instead of a directory and it doesn’t exist on the host, Docker will throw an error</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>you can mount a volume as read only  <code class="language-plaintext highlighter-rouge">-v /source:/destination:ro</code>
    <ul>
      <li>see docs (there is this optional third argument for volumes)</li>
    </ul>
  </li>
</ul>

<h3 id="the-volumes-from-flag">The <code class="language-plaintext highlighter-rouge">volumes-from</code> flag</h3>

<p>Allows you to share volumes with another container.  When you use this flag, the same volumes are mounted into your container at the same location.</p>

<p><img src="Docker-In-Action/6B5A3266-48E5-4A8F-9051-651971AD8824.png" alt="" /></p>

<p>Volumes are copied transitively, so this will automatically mount volumes that are also mounted this way from another container.</p>

<p><strong>Caveats</strong>
	- You cannot mount a shared volume to a different location within a container.  This is a limitation of <code class="language-plaintext highlighter-rouge">--volumes-from</code>
	- If you have a collision in the destination mount point among several <code class="language-plaintext highlighter-rouge">volumes-from</code> only one volume will survive, which you can ascertain from <code class="language-plaintext highlighter-rouge">docker inpsect</code>
			- see above for how to use <code class="language-plaintext highlighter-rouge">docker inspect</code>
	- You cannot change the write permission of the volume, you inherit whatever the permission is in the source container.</p>

<h3 id="cleaning-up-volumes">Cleaning up volumes</h3>

<p><code class="language-plaintext highlighter-rouge">-v</code> flag</p>

<p><code class="language-plaintext highlighter-rouge">docker rm -v</code> will delete any managed volumes referenced by the target container</p>

<p>However, if you delete all containers but forget a <code class="language-plaintext highlighter-rouge">-v</code> flag you will be left with an <strong>orphaned volume</strong>.  This is bad b/c it takes up disk space until cleaned up.  You have to run complicated cleanup steps to get rid of orphans.</p>

<p>Solution:  There is none, <strong>its a good habit to use -v anytime you call docker rm</strong></p>

<p>Hamel: this means that-</p>
<ul>
  <li>Don’t use managed volumes unless you really need it</li>
  <li>If you do use them, try to include makefiles that include <code class="language-plaintext highlighter-rouge">-v</code> as a part of things</li>
</ul>

<h3 id="advanced-volume-stuff">Advanced Volume Stuff</h3>
<ul>
  <li>You can have a volume container p. 72 so that you can reference <code class="language-plaintext highlighter-rouge">--volume-from</code> from all your containers.</li>
  <li>Data-paced volume containers, you can pre-load volume containers with data p. 73</li>
  <li>You can change the behavior of currently running containers by mounting configuration files and application in volumes.  In a way, Hamel</li>
</ul>

<h1 id="chapter-5-single-host-networking">Chapter 5 Single Host Networking</h1>
<ul>
  <li>Terminology:
    <ul>
      <li>protocols: tcp, http</li>
      <li>interfaces: IP addresses</li>
      <li>ports:  you know what this means
        <ul>
          <li>Customary ports:
            <ul>
              <li>HTTP: 80</li>
              <li>MySQL: 3306</li>
              <li>Memcached: 11211</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>Discuss advanced networking and creating a network using the <code class="language-plaintext highlighter-rouge">docker network</code> command.  Hamel: I don’t see an immediate use for this.</p>

<ul>
  <li>Special container networks:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">host</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">docker run --network host</code> allows you to pretend like the host is your local machine, and you can expose any port and that will bind to the host.</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">none</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">docker run --network none</code> closes all connection to the outside world.  This is useful for security.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="exposing-ports">exposing ports</h3>

<p><code class="language-plaintext highlighter-rouge">-p 8080</code>
This binds port 8080 to a <strong>random</strong> port on the host!  you can find the port that the container is bound to by <code class="language-plaintext highlighter-rouge">docker port &lt;image name&gt;</code>
example:
	<code class="language-plaintext highlighter-rouge">docker run -p 8080 --name listener alpine</code>
       <code class="language-plaintext highlighter-rouge">docker port listener</code></p>

<p>This will give you output that looks like <code class="language-plaintext highlighter-rouge">container --&gt; host</code> (which is reverse the other nomenclature of <code class="language-plaintext highlighter-rouge">host:container</code></p>

<p><code class="language-plaintext highlighter-rouge"> -p 8080:8080</code> this binds the container’s port to the host’s port 8080</p>

<p><code class="language-plaintext highlighter-rouge">-p 0.0.0.0:8080:8080/tcp</code> same as above but specifies the interface and the tcp protocol.</p>

<p>Syntax is <code class="language-plaintext highlighter-rouge">-p &lt;host-interface&gt;:&lt;host-port&gt;:&lt;target-port&gt;/&lt;protocol&gt;</code></p>

<h1 id="chapter-6-isolation">Chapter 6 Isolation</h1>
<h3 id="limit-resources-memory-cpu">Limit resources: Memory, CPU,</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">-m</code> or <code class="language-plaintext highlighter-rouge">--memory</code>
    <ul>
      <li>number, where unit = b, k, m or g</li>
      <li>memory limits are not reservations, just caps</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">--cpu-shares</code>
    <ul>
      <li>is a weight you set that is used to calculate % of CPU usage allowed</li>
      <li>% is calculated as weight / (sum of all weights)</li>
      <li>only enforced when there is contention for a CPU</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">--cpuset-cpus</code> : limits process to a specific CPU
    <ul>
      <li><code class="language-plaintext highlighter-rouge">docker run -d --cpuset-cpus 0</code>  Restricts to CPU number 0</li>
      <li>Can specify a list or <code class="language-plaintext highlighter-rouge">0,1,2</code> or a range <code class="language-plaintext highlighter-rouge">0-2</code></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">--device</code>
    <ul>
      <li>mount your webcam:  <code class="language-plaintext highlighter-rouge">docker run --device /dev/video0:/dev/video0</code></li>
    </ul>
  </li>
  <li>Shared memory : Hamel this was too advanced for me</li>
</ul>

<h3 id="running-as-a-user">Running as a user</h3>
<ul>
  <li>You can only inspect the default run-as User by creating or pulling the image
    <ul>
      <li>see p. 113</li>
    </ul>
  </li>
  <li>Change run-as user
    <ul>
      <li><code class="language-plaintext highlighter-rouge">docker run --user nobody</code></li>
      <li><strong>The user has to exist in the image when doing this or you will get an error</strong>.  The user will not be created automatically for you.</li>
      <li>See available users:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">docker run --rm busybox:latest awk -F: '$0=$1' /etc/passwd</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="privileged-containers-try-not-to-do-this">Privileged Containers: TRY NOT TO DO THIS</h3>
<ul>
  <li>This is how you run Docker-in-Docker</li>
  <li>Priviliged containers <strong>have root privileges on the host</strong>.</li>
  <li><code class="language-plaintext highlighter-rouge">--privilged</code> on <code class="language-plaintext highlighter-rouge">docker create</code> or <code class="language-plaintext highlighter-rouge">docker run</code></li>
</ul>

<h1 id="chapter-7-packaging-software">Chapter 7 packaging software</h1>
<p>Aside: cleaning up your docker environment</p>

<p><code class="language-plaintext highlighter-rouge">docker image prune -a</code> and <code class="language-plaintext highlighter-rouge">docker container prune</code></p>

<h3 id="recovering-changes-to-a-stopped-container">Recovering changes to a stopped container</h3>
<p>I always thought you have to commit changes in order to preserve changes to an image you made in a container.  This is not true (although committing changes is a good idea).</p>

<p><strong>Any changes you  make to a container is saved even if the container is exited</strong></p>

<p>To recover changes to a container</p>

<ol>
  <li>Find the container (if you didn’t name it with <code class="language-plaintext highlighter-rouge">docker run --name</code> it will be named for you), using <code class="language-plaintext highlighter-rouge">docker ps -a</code></li>
  <li>Start the container using <code class="language-plaintext highlighter-rouge">docker start -ai &lt;container_name&gt;</code>   the <code class="language-plaintext highlighter-rouge">-ai</code> flags mean to attach and run interactively</li>
  <li>Now you are in the container you can verify that everything you installed is still there!</li>
</ol>

<p>Note: if you run your container initially with <code class="language-plaintext highlighter-rouge">docker run --rm</code> this automatically removes your container upon exit, so this might not be recommended as your changes are not recoverable if you forget to commit</p>

<p><img src="Docker-In-Action/D79BAEDA-4071-4040-8B7B-2B864588FA9E.png" alt="" /></p>

<h3 id="seeing-changes-to-a-container-from-the-base-image">Seeing changes to a container from the base image</h3>

<p><code class="language-plaintext highlighter-rouge">docker diff &lt;container name&gt;</code> will output a long list of of file changes:
		- A: file added
		- D: file deleted
		- C: file changed</p>

<h3 id="other-tricks">Other tricks</h3>

<p>You can override the entry point to the container <strong>permanently</strong> by using the <code class="language-plaintext highlighter-rouge">--entrypoint</code> flag:  <code class="language-plaintext highlighter-rouge">docker run --entrypoint</code></p>

<h3 id="understanding-images--layers">Understanding Images &amp; Layers</h3>
<ul>
  <li>files are stored in a Union file system, so they are stored in specific layers.  The file system you are seeing as an end user are a union of all the layers.  Each time a change is made to a union file system, that change is recorded on a new layer on top of all of the others. The “union” of all of those layers, or top-down view, is what the container (and user) sees when accessing the file system.
    <ul>
      <li>This means <strong>if you are not careful you can bloat the file system by making a bunch of unnecessary changes to add/delete files.</strong></li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">docker commit</code> commits the top-layer changes to an image, meaning all the files changes are saved.</li>
</ul>

<p><strong>See image size with</strong></p>

<p><code class="language-plaintext highlighter-rouge">docker images</code>.  Even though you remove a file, the image size will increase!  This is because of the Union File System</p>

<p><strong>See size of all layers</strong></p>

<p><code class="language-plaintext highlighter-rouge">docker history &lt;image name&gt;</code></p>

<p><strong>flatten an image</strong> This is kind of complicated, you can do this by exporting and importing the filesystem into a base image See pg. 140.  BUT there is an experimental feature called <code class="language-plaintext highlighter-rouge">docker build --squash -t &lt;image&gt; .</code>You can enable experimental features by following these instructions: <a href="https://docs.docker.com/engine/reference/commandline/dockerd/#description">dockerd Docker Documentation</a>. For Mac, you can turn on experimental features by setting <code class="language-plaintext highlighter-rouge">experimental: true</code> in `settings&gt; Command Line &gt; enable experimental</p>

<h1 id="chapter-8-build-automation">Chapter 8 Build Automation</h1>
<ul>
  <li>use <code class="language-plaintext highlighter-rouge">.dockerignore</code> to prevent certain files from being copied</li>
  <li>You can set multiple environment variables at once in Dockerfile</li>
  <li>You can use environment variables in the <code class="language-plaintext highlighter-rouge">LABEL</code> command
    <ul>
      <li>The metadata makes it clear that the environment variable substitution works. You can use this form of substitution in the ENV, ADD, COPY, WORKDIR, VOLUME, EXPOSE, and USER instructions.</li>
    </ul>
  </li>
</ul>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ENV</span><span class="s"> APPROOT "/app" APP "mailer.sh" VERSION "0.6"</span>
<span class="k">LABEL</span><span class="s"> base.name "Mailer Archetype" base.version "${VERSION}"</span>
</code></pre></div></div>

<ul>
  <li>view metadata using the command <code class="language-plaintext highlighter-rouge">docker inspect &lt;image name&gt;</code></li>
</ul>

<h3 id="entrypoint-something-arugment-vs-entrypoint-something-argument">ENTRYPOINT something arugment vs. ENTRYPOINT [“something”, “argument”]</h3>

<p><strong>TLDR; use the ugly list approach</strong></p>

<p>There are two instruction forms <strong>shell form</strong> and <strong>exec form</strong> <a href="https://stackoverflow.com/questions/42805750/dockerfile-cmd-shell-versus-exec-form">docker - Dockerfile CMD shell versus exec form - Stack Overflow</a></p>

<p>The ENTRYPOINT instruction has two forms: the shell form and an exec form. The shell form looks like a shell command with whitespace-delimited arguments. The exec form is a string array where the first value is the command to execute and the remaining values are arguments. .</p>

<p><strong>Most importantly, if the shell form is used for ENTRYPOINT, then all other arguments provided by the CMD instruction or at runtime as extra arguments to docker run will be ignored. This makes the shell form of ENTRYPOINT less flexible.</strong></p>

<p>Other commands can use the <strong>exec form</strong> too!  You must use the exec form when any of the arguments contain a whitespace:</p>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> dockerinaction/mailer-base:0.6 </span>
<span class="k">COPY</span><span class="s"> ["./log-impl", "${APPROOT}"] </span>
<span class="k">RUN </span><span class="nb">chmod </span>a+x <span class="k">${</span><span class="nv">APPROOT</span><span class="k">}</span>/<span class="k">${</span><span class="nv">APP</span><span class="k">}</span> <span class="o">&amp;&amp;</span> <span class="se">\ </span><span class="nb">chown </span>example:example /var/log 
<span class="k">USER</span><span class="s"> example:example </span>
<span class="k">VOLUME</span><span class="s"> ["/var/log"]  # each value in this array will be created as a new volume definition</span>
<span class="k">CMD</span><span class="s"> ["/var/log/mailer.log"]</span>
</code></pre></div></div>
<p>Note: you usually don’t want to specify a volume at build time.</p>

<h3 id="cmd-vs-entrypoint-you-should-really-try-to-always-use-both">CMD vs. ENTRYPOINT (You should really try to always use both!)</h3>

<p>CMD is actually an argument list for the <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>.</p>

<ul>
  <li>Logically when you run a container it runs as <code class="language-plaintext highlighter-rouge">&lt;default shell program&gt; ENTRYPOINT CMD</code></li>
  <li>You can override the <code class="language-plaintext highlighter-rouge">ENTRYPOINT</code> with <code class="language-plaintext highlighter-rouge">docker run --entrypoint</code>, and you can override commands by just passing commands to docker run :  <code class="language-plaintext highlighter-rouge">docker run &lt;image name&gt; &lt;command&gt;</code></li>
</ul>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> ubuntu</span>

<span class="k">ENTRYPOINT</span><span class="s"> [ "ls" ]</span>
<span class="k">CMD</span><span class="s"> ["-lah"]</span>
</code></pre></div></div>

<p>As you can see using ENTRYPOINT as well as CMD separately provides your downstream users with the most flexibility.</p>

<h3 id="copy-vs-add">COPY vs ADD</h3>

<p>Use COPY.  ADD has additional functionality like ability to download from urls and decompress files, which proved opaque over time and you shouldn’t use it.</p>

<h3 id="onbuild">ONBUILD</h3>

<p>The ONBUILD instruction defines instructions to execute if the resulting image is used as a base for another build.  those ONBUILD instructions are executed after the FROM instruction and before the next instruction in a Dockerfile.</p>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> busybox:latest </span>
<span class="k">WORKDIR</span><span class="s"> /app RUN touch /app/base-evidence </span>
<span class="k">ONBUILD RUN </span><span class="nb">ls</span> <span class="nt">-al</span> /app
</code></pre></div></div>

<h3 id="other-stuff">Other Stuff</h3>
<ul>
  <li>You should always validate the presence of required environment variables in a startup shell script like <code class="language-plaintext highlighter-rouge">entrypoint.sh</code></li>
</ul>

<h3 id="docker-digests">Docker Digests</h3>
<p>Reference the exact SHA of a Container which is the only way to guarantee the image you are referencing has not changed.   @ symbol followed by the digest.</p>

<p>Hamel: doesn’t look like a good way to find history of digests, but you can see the current SHA when you use <code class="language-plaintext highlighter-rouge">docker pull</code> , you can see the SHA as well if you call <code class="language-plaintext highlighter-rouge">docker images --digests</code></p>

<div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> debian@sha256:d5e87cfcb730...</span>
</code></pre></div></div>

<h1 id="chapter-10-skipped-ch-9">Chapter 10 (skipped Ch 9)</h1>
<ul>
  <li>You can run your own customized registry.  Simplest version can be hosted from a Docker Container!</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># start a local registry on port 5000</span>
docker run <span class="nt">-d</span> <span class="nt">--name</span> personal_registry
 <span class="se">\ </span><span class="nt">-p</span> 5000:5000 <span class="nt">--restart</span><span class="o">=</span>always 
 <span class="se">\ </span>registry:2

<span class="c"># push an image to the registry (using the same image that created the registry for convenience)</span>
docker tag registry:2 localhost:5000/distribution:2 
docker push localhost:5000/distribution:2
</code></pre></div></div>

<p>Note that <code class="language-plaintext highlighter-rouge">docker push</code> syntax is actually <code class="language-plaintext highlighter-rouge">docker push &lt;registry url&gt;/org/repo</code></p>

<p>This chapter discusses many more things which are skipped:
	- Centralized registries
	- Enhancements
	- Durable blog storage
	- Integrating through notifications</p>

<h1 id="chapter-11-docker-compose">Chapter 11 Docker Compose</h1>
<p>Docker compose for fastpages:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3"</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">fastpages</span><span class="pi">:</span> <span class="nl">&amp;fastpages</span>
    <span class="na">working_dir</span><span class="pi">:</span> <span class="s">/data</span>
    <span class="na">environment</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="s">INPUT_BOOL_SAVE_MARKDOWN=false</span>
    <span class="na">build</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">./_action_files</span>
      <span class="na">dockerfile</span><span class="pi">:</span> <span class="s">./Dockerfile</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">fastpages-dev</span>
    <span class="na">logging</span><span class="pi">:</span>
      <span class="na">driver</span><span class="pi">:</span> <span class="s">json-file</span>
      <span class="na">options</span><span class="pi">:</span>
        <span class="na">max-size</span><span class="pi">:</span> <span class="s">50m</span>
    <span class="na">stdin_open</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">tty</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">.:/data/</span>

  <span class="na">converter</span><span class="pi">:</span>
    <span class="s">&lt;&lt;</span><span class="pi">:</span> <span class="nv">*fastpages</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">/fastpages/action_entrypoint.sh</span>

  <span class="na">watcher</span><span class="pi">:</span>
    <span class="s">&lt;&lt;</span><span class="pi">:</span> <span class="nv">*fastpages</span>
    <span class="na">command</span><span class="pi">:</span> <span class="s">watchmedo shell-command --command /fastpages/action_entrypoint.sh --pattern *.ipynb --recursive --drop</span>

  <span class="na">jekyll</span><span class="pi">:</span>
    <span class="na">working_dir</span><span class="pi">:</span> <span class="s">/data</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">hamelsmu/fastpages-jekyll</span>
    <span class="na">restart</span><span class="pi">:</span> <span class="s">unless-stopped</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">4000:4000"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">.:/data/</span>
    <span class="na">command</span><span class="pi">:</span> <span class="pi">&gt;</span>
     <span class="s">bash -c "gem install bundler</span>
     <span class="s">&amp;&amp; jekyll serve --trace --strict_front_matter"</span>

</code></pre></div></div>

<p>The above uses YAML anchors: <a href="https://confluence.atlassian.com/bitbucket/yaml-anchors-960154027.html">YAML anchors - Atlassian Documentation</a></p>

<p>Start a particular service: <code class="language-plaintext highlighter-rouge">docker-compose up &lt;service name&gt;</code>
Rebuild a service <code class="language-plaintext highlighter-rouge">docker-compose build &lt;service name&gt;</code></p>

<p>You can express dependencies with <code class="language-plaintext highlighter-rouge">depends_on</code> which is useful for compose to know which services to restart or start in a specified order.</p>

<p>See examples of Docker Compose files on p 243</p>

<h3 id="scaling-up-wdocker-compose">Scaling Up w/Docker Compose</h3>
<p>That’s right you don’t need docker swarm.  This example uses <a href="https://github.com/dockerinaction/ch11_coffee_api/blob/master/docker-compose.yml">ch11_coffee_api/docker-compose.yml at master · dockerinaction/ch11_coffee_api · GitHub</a></p>

<ol>
  <li>Get  list of containers that are currently providing the service.</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">docker-compose ps coffee</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          Name                 Command       State            Ports
----------------------------------------------------------------------------
ch11_coffee_api_coffee_1   ./entrypoint.sh   Up      0.0.0.0:32768-&gt;3000/tcp
</code></pre></div></div>

<ol>
  <li>Scale it up with <code class="language-plaintext highlighter-rouge">docker-compose up --scale</code></li>
</ol>

<p><code class="language-plaintext highlighter-rouge">docker-compose up --scale coffee=5</code></p>

<p>When you run <code class="language-plaintext highlighter-rouge">docker-compose ps coffee</code>:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker-compose ps coffee                                                                                                                         ✔
          Name                 Command       State            Ports
----------------------------------------------------------------------------
ch11_coffee_api_coffee_1   ./entrypoint.sh   Up      0.0.0.0:32768-&gt;3000/tcp
ch11_coffee_api_coffee_2   ./entrypoint.sh   Up      0.0.0.0:32769-&gt;3000/tcp
ch11_coffee_api_coffee_3   ./entrypoint.sh   Up      0.0.0.0:32771-&gt;3000/tcp
ch11_coffee_api_coffee_4   ./entrypoint.sh   Up      0.0.0.0:32770-&gt;3000/tcp
ch11_coffee_api_coffee_5   ./entrypoint.sh   Up      0.0.0.0:32772-&gt;3000/tcp
</code></pre></div></div>

<p>Note that the coffee service binds to port <code class="language-plaintext highlighter-rouge">0</code> on your host, which is an <strong>ephemeral port</strong>, which just means that your host machine assigns the service to a random port.  This is required if you plan on using <code class="language-plaintext highlighter-rouge">docker compose up --scale</code></p>

<p>The service was bound to port 0 on the host with</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">coffee</span><span class="pi">:</span>
  <span class="na">build</span><span class="pi">:</span> <span class="s">./coffee</span>
  <span class="na">user</span><span class="pi">:</span> <span class="s">777:777</span>
  <span class="na">restart</span><span class="pi">:</span> <span class="s">always</span>
  <span class="na">expose</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="m">3000</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s2">"</span><span class="s">0:3000"</span>
<span class="nn">...</span>
</code></pre></div></div>

<ol>
  <li>Load balancer</li>
</ol>

<p>Problem with this kind of scaling is you don’t know the ports in advance , and you don’t want to hit these individual endpoints, you need a load balancer.  This <a href="https://pspdfkit.com/blog/2018/how-to-use-docker-compose-to-run-multiple-instances-of-a-service-in-development/#adding-a-load-balancer">blog post</a> shows you how to luse NGINX as a load balancer.</p>

<p>You will need something like this in your compose file</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:latest</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">./nginx.conf:/etc/nginx/nginx.conf:ro</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">pspdfkit</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">4000:4000"</span>
</code></pre></div></div>

<h3 id="templating-docker-compose-files">Templating Docker Compose Files</h3>
<p>You can read about this here: <a href="https://docs.docker.com/compose/extends/">Share Compose configurations between files and projects | Docker Documentation</a>, allows you to override certain things from a base compose file.</p>

<h1 id="chapter-12-clusters-wmachine--swarm">Chapter 12 Clusters w/Machine &amp; Swarm</h1>
<p>Hamel: I skipped this completely</p>
