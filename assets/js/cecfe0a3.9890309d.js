"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[1522],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=a.createContext({}),c=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(i.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=o,h=d["".concat(i,".").concat(m)]||d[m]||u[m]||r;return n?a.createElement(h,s(s({ref:t},p),{},{components:n})):a.createElement(h,s({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,s=new Array(r);s[0]=d;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:o,s[1]=l;for(var c=2;c<r;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},582:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return i},metadata:function(){return c},assets:function(){return p},toc:function(){return u},default:function(){return m}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),s=["components"],l={},i=void 0,c={unversionedId:"k8s/StatefulSet",id:"k8s/StatefulSet",title:"StatefulSet",description:"[!Warning]",source:"@site/docs/k8s/12-StatefulSet.md",sourceDirName:"k8s",slug:"/k8s/StatefulSet",permalink:"/k8s/StatefulSet",editUrl:"https://github.dev/hamelsmu/notes/blob/master/docs/k8s/12-StatefulSet.md",tags:[],version:"current",sidebarPosition:12,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Sharing Processes in MC Pods",permalink:"/k8s/Sharing Processes in MC Pods"},next:{title:"Jobs",permalink:"/k8s/Jobs and CronJobs"}},p={},u=[],d={toc:u};function m(e){var t=e.components,n=(0,o.Z)(e,s);return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"[!Warning]","\nHamel: you probably don't need this. JUST SKIP THESE NOTES")),(0,r.kt)("p",null,"[","[StatefulSet]","] is a Pod controller, just like [","[5. ReplicaSets]","] or [","[DaemonSets]","]"),(0,r.kt)("p",null,"When you deploy a StatefulSet, it creates Pods with predictable names, which can be individually accessed over DNS, and starts them in order; the first Pod needs to be up and running before the second Pod is created."),(0,r.kt)("p",null,"If you are trying to model database on K8s, you might use ",(0,r.kt)("inlineCode",{parentName:"p"},"StatefulSet"),".  However, don't put DBs on K8s - use a managed service for that instead.  ",(0,r.kt)("inlineCode",{parentName:"p"},"StatefulSet")," just gives you determinstic Pod names and networking, you have to take care of synching your apps yourself.   That would be outside the scope of what DS should do IMO."),(0,r.kt)("p",null,"Here is ",(0,r.kt)("inlineCode",{parentName:"p"},"kind: StatefulSet")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"}," % cat todo-list/db/todo-db.yaml                                                                                                      \napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: todo-db\n  labels:\n    kiamol: ch08\nspec:\n  selector:\n    matchLabels:\n      app: todo-db\n  serviceName: todo-db\n  replicas: 2\n  template:\n    metadata:\n      labels:\n        app: todo-db\n")),(0,r.kt)("p",null,"When you get pods, they will be incremented from ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),", this allows you network/communicate with them deterministically. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"% kl get po                                                                                                                         \nNAME        READY   STATUS    RESTARTS   AGE\ntodo-db-0   1/1     Running   0          23s\ntodo-db-1   1/1     Running   0          21s\n")),(0,r.kt)("p",null,"StatefulSet is a controller, so if you delete a pod the ",(0,r.kt)("inlineCode",{parentName:"p"},"StatefulSet")," will recreate it."),(0,r.kt)("h1",{id:"initcontainers"},"InitContainers"),(0,r.kt)("p",null,"You can bootstrap pods with initcontainers and stateful sets.  For example. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: StatefulSet\n...\n      initContainers:\n        - name: wait-service\n          image: kiamol/ch03-sleep\n          envFrom:\n          - configMapRef:\n              name: todo-db-env\n          command: ['/scripts/wait-service.sh']\n")),(0,r.kt)("p",null,"The script says if its running in Pod 0 do nothing, but if its running in Pod 1 then replicate the master.  This is just an idea, you probably should never do this yourself. "),(0,r.kt)("h1",{id:"networking-in-statefulsets"},"Networking In StatefulSets"),(0,r.kt)("p",null,'You need to have a special configuration "headless Service" to setup newtworking for StatefulSets, by setting ',(0,r.kt)("inlineCode",{parentName:"p"},"ClusterIP: None")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"%cat todo-list/db/todo-db-service.yaml                                                                                              \napiVersion: v1\nkind: Service\nmetadata:\n  name: todo-db\n  labels:\n    kiamol: ch08\nspec:\n  ports:                  # 5432 is the port Postgres uses\n    - port: 5432\n      targetPort: 5432 \n      name: postgres\n  selector:\n    app: todo-db\n  clusterIP: None             # Note how this is None\n")),(0,r.kt)("p",null,"The pod will be reachable at ",(0,r.kt)("inlineCode",{parentName:"p"},"pod-name.service-name.cluster-domain-suffix"),". for example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"todo-db-0.todo-db.default.svc.cluster.local\n")),(0,r.kt)("p",null,"See: ",(0,r.kt)("a",{parentName:"p",href:"https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id"},"https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#stable-network-id")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'A StatefulSet can use a Headless Service to control the domain of its Pods. The domain managed by this Service takes the form: $(service name).$(namespace).svc.cluster.local, where "cluster.local" is the cluster domain. As each Pod is created, it gets a matching DNS subdomain, taking the form: $(podname).$(governing service domain), where the governing service is defined by the serviceName field on the StatefulSet.')),(0,r.kt)("p",null,"This is also related to the ",(0,r.kt)("inlineCode",{parentName:"p"},"serviceName")," field on the StatefulSet"),(0,r.kt)("p",null,"You can lookup the ",(0,r.kt)("inlineCode",{parentName:"p"},"cluster-domain-suffix")," like this : "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kl exec deploy/sleep -- sh -c 'nslookup todo-db'`\n")),(0,r.kt)("p",null,"The headless service still does load balancing, but lets you access the Pod"),(0,r.kt)("h1",{id:"storage"},"Storage"),(0,r.kt)("p",null,"For DBs you want each pod to have its own persistent disk, there is a shortcut: using ",(0,r.kt)("inlineCode",{parentName:"p"},"volumeClaimTemplates")," which makes sure each Pod in the stateful set always gets its own persistent volume.  "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"% cat sleep/sleep-with-pvc.yaml                                             \n...\nkind: StatefulSet\n  template:\n    ...\n  volumeClaimTemplates:\n  - metadata:\n      name: data\n      labels:\n        kiamol: ch08\n    spec:\n      accessModes:\n       - ReadWriteOnce\n      resources:\n        requests:\n          storage: 5Mi\n")),(0,r.kt)("p",null,"Each pod will get a PVC created dynamically, which will create a Persistent Volume using the default storage class (or the requested storage class if included in the spec)."),(0,r.kt)("p",null,"The link b/w each pod and its PVC is maintained when pods are replaced.   For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# create a file\nkl exec sleep-with-pvc-0 -- sh -c 'echo pod 0 > /data/pod.txt'\n\n#delete the pod\nkl delete po sleep-with-pvc-0\n\n# this will show the right contents\nkl exec sleep-with-pvc-0 -- cat /data/pod.txt\n")))}m.isMDXComponent=!0}}]);