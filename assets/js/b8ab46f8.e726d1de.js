"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[621],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=p(n),d=i,h=c["".concat(s,".").concat(d)]||c[d]||m[d]||r;return n?a.createElement(h,l(l({ref:t},u),{},{components:n})):a.createElement(h,l({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9097:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return p},assets:function(){return u},toc:function(){return m},default:function(){return d}});var a=n(7462),i=n(3366),r=(n(7294),n(3905)),l=["components"],o={title:"programming languages",sidebar_position:6},s=void 0,p={unversionedId:"programming-languages/pl",id:"programming-languages/pl",title:"programming languages",description:"High level takeaways after completing the 3-Part Coursera class Programming Languages with Dan Grossman.",source:"@site/docs/programming-languages/pl.md",sourceDirName:"programming-languages",slug:"/programming-languages/pl",permalink:"/programming-languages/pl",editUrl:"https://github.dev/hamelsmu/notes/blob/master/docs/programming-languages/pl.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"programming languages",sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Processes, Permissions and Moving Data",permalink:"/linux/permprocdata"}},u={},m=[{value:"SML (Standard ML) Part A",id:"sml-standard-ml-part-a",level:2},{value:"Racket (Part B)",id:"racket-part-b",level:2},{value:"Ruby (Part C)",id:"ruby-part-c",level:2},{value:"Blocks",id:"blocks",level:3},{value:"Subclassing",id:"subclassing",level:4},{value:"Typing",id:"typing",level:3},{value:"VIM",id:"vim",level:2}],c={toc:m};function d(e){var t=e.components,n=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"High level takeaways after completing the ",(0,r.kt)("a",{parentName:"p",href:"https://www.coursera.org/learn/programming-languages"},"3-Part Coursera class Programming Languages")," with Dan Grossman."),(0,r.kt)("p",null,"Your GitHub repo for this class (private) ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/hamelsmu/programming-languages-class"},"is here"),"."),(0,r.kt)("h2",{id:"sml-standard-ml-part-a"},"SML (Standard ML) Part A"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"You setup vim to have an IDE for this.  See notes in the VIM section below.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"ML is a statically typed language with magical ",(0,r.kt)("strong",{parentName:"p"},"type inference")," that works really well.  It automatically determines the types and is very intuitive and helpful.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Learned how to use recursion everywhere instead of loops, particularly with ",(0,r.kt)("inlineCode",{parentName:"p"},"hd"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"tl")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"cons"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Local variable binding with ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," is very important (which also allows you to bind local/private functions as well)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"cons")," allows you to append to the beginning of a list")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"There is an option type that is ",(0,r.kt)("inlineCode",{parentName:"p"},"NONE")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"SOME v"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"This language doesn't encourage mutation, which is a feature.  Otherwise, you can use a reference which is like a pointer to mutate a variable.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"pattern matching with a case expression"),":  This is one of the coolest things that I learned, and something similar ",(0,r.kt)("a",{parentName:"p",href:"https://www.python.org/dev/peps/pep-0636/"},"is coming to Python v 3.10"),"."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"You can have nested patterns"),(0,r.kt)("li",{parentName:"ul"},"You can pattern match against function arguments which allow for really nice syntax for achieving multiple dispatch type of functionality.. (not sure about python)"),(0,r.kt)("li",{parentName:"ul"},"You can pattern match against types as well as data structures."),(0,r.kt)("li",{parentName:"ul"},"You can have constants in there as well.",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ml"},'case name \n     NameType name => ...\n   | (first, "MyLastName") => ...\n   | (first, last) => ...\n   | name => ...\n   | _ => ...\n'))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Tail recursion")," with accumulators.  Ex- factorial")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"fn")," keyword is used to define ",(0,r.kt)("strong",{parentName:"p"},"anonymous functions"),".")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"ML uses ",(0,r.kt)("inlineCode",{parentName:"p"},"lexical scope")," which means function is evaluated in the environment where the function was defined. ",(0,r.kt)("inlineCode",{parentName:"p"},"dynamic scope"),", which is usually not desired, is the alternative where the function is evaluated in the in the environment it is called.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Closure"),' - the call stack has a "pair" that is the (function, environment when the function was defined).  This pair is called the ',(0,r.kt)("inlineCode",{parentName:"p"},"closure"),".  The call stack has a snapshot of what the environment looked like at the time the function was defined. ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"fold")," is like reduce.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"ML supports ",(0,r.kt)("strong",{parentName:"p"},"function composition")," like this with  the keyword ",(0,r.kt)("inlineCode",{parentName:"p"},"o"),":  ",(0,r.kt)("inlineCode",{parentName:"p"},"f1 o f2 o f3")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"best to do a val binding to avoid unnecessary wrapping: ",(0,r.kt)("inlineCode",{parentName:"li"},"val newfunc = f1 o f2")),(0,r.kt)("li",{parentName:"ul"},"with ",(0,r.kt)("inlineCode",{parentName:"li"},"o")," you apply functions from right to left so ",(0,r.kt)("inlineCode",{parentName:"li"},"f1 o f2 x")," is the same as ",(0,r.kt)("inlineCode",{parentName:"li"},"f1(f2(x))")," there is an alternative that is left to right called the ",(0,r.kt)("inlineCode",{parentName:"li"},"pipeline operator"),"."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Currying and partial application")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Universal way to make a func curryable:",(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-ml"},"fun myfunc x\n    let fun f2 (z) = z\n        fun f1 (y) = f2(y)\n    begin\n        f1\n    end\n"))),(0,r.kt)("li",{parentName:"ul"},"ML has first class support for currying so you don't have to do the above hack. "))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"ML supports mutual recursion just like ",(0,r.kt)("inlineCode",{parentName:"p"},"let-rec")," in racket."))),(0,r.kt)("h2",{id:"racket-part-b"},"Racket (Part B)"),(0,r.kt)("p",null,"Racket is related to Lisp and Scheme. Everything is a function.  Parenthesis for everything. The position of parenthesis changes the meaning of the code."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Racket has dynamic typing, unlike SML. "),(0,r.kt)("li",{parentName:"ul"},"Thunks: Wrap a function in a zero argument function to delay evaluation. Applications:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Streams: the function will return a tuple of (value, func), and when you call func it will return (value, func) so you get one value at a time. This is not specific to Racket."),(0,r.kt)("li",{parentName:"ul"},"Lazy evaluation:  You can use thunks to delay execution like a promise to a later time.  This is an example of lazy evalution that doesn't actually evaluate anything until being forced to: ")))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-racket"},"(define (my-delay f) (mcons #f f))\n\n(define (my-force th)\n\n(if (mcar th) (mcdr th) (begin (set-mcar! th #t) (set-mcdr! th ((mcdr th))) (mcdr th))))\n")),(0,r.kt)("p",null,"Racket allows you use ",(0,r.kt)("strong",{parentName:"p"},"macros"),' that will evaluate before the code is run and that will "expand" into valid racket syntax.  '),(0,r.kt)("p",null,"You implemented your own small programming language.  This used recursive calls to evluate expressions with the base case being the values (Integer, strings, etc)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'- Interperter: write a program in another language A that takes programs in B and produces answers directly. A better term would be "evaluator".\n- Compiler: write program in another language A that takes programs in B and produces an equivalent program in langauage C.  A better term here would be "translator".\n')),(0,r.kt)("p",null,"Closures: for lexical scope, the interpreter has a stack of tuples.  The tuples are (1) the function to be called (2) the environment, which contains the value of all variables at the time the function was defined.  You also have to track the arguments for the function seperately, so you can evaluate the arguments in the environment the function was run in. "),(0,r.kt)("h2",{id:"ruby-part-c"},"Ruby (Part C)"),(0,r.kt)("p",null,"I didn't spend too much time some concepts I was mostly familiar with this.  "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Ruby is OOP, dynamically typed. ")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Ruby is pure OOP, even top level functions and variables are part of the built-in ",(0,r.kt)("inlineCode",{parentName:"p"},"Object")," class.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"They have fastcore like shortcuts for getters and setters:"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"attr_reader :y, :z # defines getters \nattr_accessor :x # defines getters and setters\n")),(0,r.kt)("p",null,"newlines are important.  The syntax can change without them."),(0,r.kt)("p",null,"Dynamic class definitions.  The following code will result in ",(0,r.kt)("inlineCode",{parentName:"p"},"Class")," with the methods ",(0,r.kt)("inlineCode",{parentName:"p"},"foo")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"bar"),"!  The second one doesn't override the first one!"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rb"},"class Class\n    def foo\n        ...\n    end\nend\n\nclass Class\n    def bar\n        ...\n    end\nend\n")),(0,r.kt)("h3",{id:"blocks"},"Blocks"),(0,r.kt)("p",null,"They also have a very convenient lambda like thing called ",(0,r.kt)("inlineCode",{parentName:"p"},"Blocks"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"sum = 0 \n[4,6,8].each { |x| sum += x \n               puts sum }\n")),(0,r.kt)("p",null,"You can use Blocks to make accumulators too, and even use ",(0,r.kt)("inlineCode",{parentName:"p"},"inject")," to initialize the accumulator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"sum = [4,6,8].inject(0) { |acc,elt| acc + elt }\n")),(0,r.kt)("p",null,"To use blocks in a method, you will have to look that up in the docs. This involves the ",(0,r.kt)("inlineCode",{parentName:"p"},"yield"),' keyword.  For example, this code will print "hi" 3 times:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},'def foo x \n  if x \n    yield \n   else \n    yield \n    yield \n   end \nend \n\nfoo (true) { puts "hi" } \nfoo (false) { puts "hi" }\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Blocks")," are not first class functions even though they kind of look like lambdas.  Lets say you wanted to map over an array but wanted to return an array of functions instead of values.  The way to do this is to use the keyword ",(0,r.kt)("inlineCode",{parentName:"p"},"lambda"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"c = a.map {|x| {|y| x >= y} } # wrong, a syntax error\n\nc = a.map {|x| lambda {|y| x >= y} } # this will work\n")),(0,r.kt)("h4",{id:"subclassing"},"Subclassing"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"super")," calls the same method in the parent class.  You dont have to do super.method_name(), just ",(0,r.kt)("inlineCode",{parentName:"li"},"super"),". "),(0,r.kt)("li",{parentName:"ul"},"Instance variables are preceeded with ",(0,r.kt)("inlineCode",{parentName:"li"},"@"))),(0,r.kt)("p",null,"Child classes are defined like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ruby"},"class Child < Parent\n ...\nend\n")),(0,r.kt)("h3",{id:"typing"},"Typing"),(0,r.kt)("p",null,"They discussed the various ways different type systems are constructed.  The interface idiom, that is familar to you from Golang (but not specific to Golang) was introduced."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"vim"},"VIM"),(0,r.kt)("p",null,"For the Standard ML programming language I decided to force myself to use vim.  I added the following things to my ",(0,r.kt)("inlineCode",{parentName:"p"},".vimrc")," to make it manageable.  Note the plugin ",(0,r.kt)("inlineCode",{parentName:"p"},"jez/vim-better-sml")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\" from https://github.com/jez/vim-as-an-ide\nset nocompatible\n\ninoremap <C-e> <C-o>A\n\n\nfiletype off\n\nset rtp+=~/.vim/bundle/Vundle.vim\ncall vundle#begin()\n\nPlugin 'VundleVim/Vundle.vim'\n\n\" ----- Making Vim look good ------------------------------------------\nPlugin 'altercation/vim-colors-solarized'\nPlugin 'tomasr/molokai'\nPlugin 'vim-airline/vim-airline'\nPlugin 'vim-airline/vim-airline-themes'\n\n\" ----- Vim as a programmer's text editor -----------------------------\nPlugin 'scrooloose/nerdtree'\nPlugin 'jistr/vim-nerdtree-tabs'\nPlugin 'vim-syntastic/syntastic'\nPlugin 'xolox/vim-misc'\nPlugin 'xolox/vim-easytags'\nPlugin 'majutsushi/tagbar'\nPlugin 'ctrlpvim/ctrlp.vim'\n\" ----- Working with Git ----------------------------------------------\nPlugin 'airblade/vim-gitgutter'\nPlugin 'tpope/vim-fugitive'\nPlugin 'Raimondi/delimitMate'\nPlugin 'jez/vim-better-sml'\nPlugin 'christoomey/vim-tmux-navigator'\nPlugin 'benmills/vimux'\ncall vundle#end()\n\nfiletype plugin indent on\n\nset number\nset ruler\nset showcmd\nset incsearch\nset hlsearch\nset backspace=indent,eol,start\n\nsyntax on\nset mouse=a\n")))}d.isMDXComponent=!0}}]);